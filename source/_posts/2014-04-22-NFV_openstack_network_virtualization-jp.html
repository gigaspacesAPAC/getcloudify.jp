---
layout: blogpost
title: OpenStackにおけるNFVコンポーネントの自動化の方法
lang: jp
categories:
    - jp
image: shaynaeh.jpg
author: Shay Naeh
tags: 
 - NFV
 - NFV Orchestration
 - OpenStack 
 - Cloud Orchestration 
 - Cloud Automation
---
<notextile>

<p>前回の記事では、クラウドにおける<a href="http://getcloudify.org/2014/04/09/network_automation_NFV_cloud_orchestration.html">ネットワーク機能の仮想化</a>の必要性について述べました。この記事では、実際に手軽に試すことができる現実的なシナリオについて説明します (ご存知かと思いますが、当社ではローカルクラウドもサポートしています)。</p>

<p>要約すると、クラウドでネットワークコンポーネントを仮想化する場合の主な課題は、展開フェーズであろうと展開後のフェーズであろうと関係なく、一般的には、自動化に関する以下のようなものです。</p>

<p>1. 自動デプロイメント</p>

<p>2. オーケストレーション</p>

<p>3. モニタリング</p>

<p>4. セルフヒーリング</p>

<p>5. オートスケーリング</p>

<p>以下に、私がCloudifyを利用してOpenStack上でこれらを実現した方法を紹介します。</p>

<p><strong>ソリューション</strong></p>

<p>1. <strong>自動デプロイメント</strong>および階層間の依存関係に関しては、<a href="http://getcloudify.org/">Cloudify</a>を利用しました。Cloudifyを利用すると、レシピおよびコンポーネント間の依存関係を簡単に記述することができます。私が行った実験では、ビデオストリーマーを作成するオフザシェルフソフトウェアを利用し、それをTomcat Webコンテナで実行しました。Tomcatと仮想ソフトウェアロードバランサーを使用して、弾力性を実現しました。Tomcatは自身を仮想ロードバランサー (私がApacheを利用して作成) に登録します。Apacheの詳細については、<a href="http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html">mod_proxy_balancer</a>を参照してください。このApacheベースのロードバランサーは、事前に定義されたポリシーに基づいてトラフィックを複数のビデオストリーマーにダイレクトする仮想ネットワーク機能を提供します。私は、簡易なラウンドロビンポリシーを使用してTomcatサーバー間で要求が均等にダイレクトされるようにしました。</p>

<p>また、Tomcatコネクターを使用して、新しいTomcatが起動する度にロードバランサーに接続し、「追加のビデオストリーマーがあり、自身が利用可能なのでトラフィックをダイレクトしても構わない」ということを通知するようにしました。</p>

<hr>

<span class="pullquote-left">
  <font style="font-weight: bold" size="5" face="Baskerville Old Face"><em>「Cloudify + NFV」は、もはや、単なるトレンドではありません。試してみてください。</em></font>&nbsp; <a class="btn btn-large btn-theme btn-rounded" id="downloadBtnInner" href="http://getcloudify.org/downloads/get_cloudify_3x.html" target="_blank"><i class="icon-plus"></i> Go </a></span>
  
  <hr>

<p>ビデオストリーミングについては、最小限の構成で済む<a href="http://www.subsonic.org/pages/index.jsp">Subsonic</a>を使用しました。各種のMP3ファイルとMP4ファイル (音声と映像) をアップロードし、デスクトップブラウザーで再生したり、Google PlayやApple Appストアからダウンロードできるクライアントアプリケーションを使用してAndroidやiPhoneモバイルデバイスで再生したりしました。</p>

<p>ここで注目すべきは、Tomcatビデオストリーマーはロードバランサーが起動しない限り開始されないこと、つまり、Tomcatとロードバランサーは依存関係にあるということです。この依存関係を以下のレシピに記述します。サービス作成、およびTomcatとロードバランサーは依存関係は、以下のとおりです。</p>

<script src="https://gist.github.com/shayn1234/9503883.js"></script>

<p>2. <strong>オーケストレーション：</strong>Cloudifyがネットワークインフラストラクチャオーケストレーションを処理し、そのようにすることでNFVコンポーネントの展開が可能になります。Cloudifyは、OpenStackにおけるネットワーク、サブネット、セキュリティグループ、浮動IP、管理ネットワーク、およびアプリケーションネットワークを定義します。OpenStackにおけるサブネットは、最初に作成されたネットワークに依存します。ここでは、以下のように、Cloudifyドライバーのコードスニペットを利用して、管理ネットワーク、およびアプリケーションネットワークのプロビジョニングを定義します。</p>

<script src="https://gist.github.com/shayn1234/9525858.js"></script>

<p>Cloudifyは、上記のように定義されたアプリケーションサービスと依存関係もオーケストレーションします。</p>

<p>3. <strong>モニタリング：</strong>オーケストレーションの一部であり、収集して処理基準とするメトリクスを定義します。メトリクスとして、例えば、要求の数、スループット (実質的には、指定時間単位における要求数)、Tomcatで使用されているようなドメイン固有のメトリクス、ビジースレッドの数などを指定することができます。メトリクスを使用して、システム、アプリケーション、および内部リソースの現在の状態が表示されます。また、メトリクスは、セルフヒーリングや自動スケーリングといった付加的なアクティブタスクにも使用されます。これらのタスクについては、以降で説明します。モニタリングは、SNMP、CLI、JMXなど、さまざまな収集方法を使用して、任意のデータソースに適用することができます。私が使用したモニタリングの例は、以下のとおりです。JMXを利用してTomcatサーバーからメトリクスを収集しました。</p>

<script src="https://gist.github.com/shayn1234/9526025.js"></script>

<p>4. <strong>セルフヒーリング：</strong>Tomcatサーバーまたはロードバランサーが機能停止状態になった場合は、Cloudifyが新しいサーバーまたはロードバランサーを起動します。Cloudifyは、自身で管理しているサービスを定期的にモニタリングして、この状態を認識します。サービスは、クラッシュした場合には、レシピに定義されているように自動的に起動されます。</p>

<p>5. <strong>自動スケーリング：</strong>負荷、ユーザー、および付加的なトランザクションが急増した場合は、どうしますか？また、負荷が高い時間帯にはキャパシティを拡大し、通常の状態になったらキャパシティを元に戻すには、どのような方法をとりますか？そのためには、弾力的な自動ソリューション、つまり、自動スケーリングソリューションが必要です。</p>

<p>以下のアーキテクチャ図は、仮想ロードバランサーから仮想ビデオストリーマーへのトラフィックフローと共に、実際のクライアントからの要求を模すための負荷生成を示しています。負荷を生成して自動スケーリングルールをチェックします。Tomcatを使用したレシピでは、以下のルールを追加しました。</p>

<script src="https://gist.github.com/shayn1234/9526498.js"></script>

<p>これは、自動化全体の流れを制御するCloudifyに対し、2つのTomcatインスタンスを開始し、モニタリングされたメトリクス (「Current HTTP Threads Busy」) に基づいて、しきい値4を超えた場合はサーバーの数を2つ増やすように指示するものです (しきい値は指定可能であるため、さらに大きい値にすることもできます)。私は、結果をすぐに確認できるように、しきい値を4に設定しました。Cloudifyは、JMXを利用してTomcatからビジースレッドの数を受け取り、次に、定義されているしきい値とそれを比較します。</p>

<p><img src="/images/NFVPost-Cloudify.jpg"></p>

<p>以下は、デスクトップブラウザーに表示されているSubsonicの画面です (画面提供：Subsonic)。</p>

<p><img src="/images/NFPost-Subsonic.jpg"></p>

<p>数名の友人の携帯電話を使用して、多数の携帯電話をつなぎ、それぞれの携帯電話で各人が音楽を聴いたり、映像を再生したりすることができました。</p>

<p>ロードバランサーを実行し、ユーザーのセッションが同じビデオストリーマーにダイレクトされ続けるようにCookieを調整した後、ユーザーが操作を開始したところ、すべて順調に機能しました。ユーザーはTomcat上で実行されているビデオストリーマーにダイレクトされ、定義されているしきい値をビデオストリーマー (より正確には、Tomcatスレッド) が超えると、追加のTomcatsサーバーが投入され、それらが自動的にロードバランサーに登録されて、さらなるユーザーと要求に対応する準備が整えられました。</p>

<p>もう一言、<strong>自動スケーリング</strong>について付け加えるならば、システムがアイドル状態であり、システムを使用するクライアントの数が少ない場合には、サーバーが解放されて、使用可能な仮想ビデオストリーマーの数が減らされるということです。つまり、オンデマンドで拡大/縮小する100%の弾力性を備えたシステムが実現するということです。</p>

<p>現在では、私は、仮想ロードバランサーコンポーネントを他の目的のために仮想NFVコンポーネント (私のカタログにある既存のNVFコンポーネント) として使用できるようになりました。</p>

</notextile>
